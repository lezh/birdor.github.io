<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>鸟兰</title>
        <description>鸟兰 - Le Oliver Zhuang</description>
        <link>http://birdor.github.io</link>
        <link>http://birdor.github.io</link>
        <lastBuildDate>2014-07-30T16:37:00+08:00</lastBuildDate>
        <pubDate>2014-07-30T16:37:00+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>看那快乐的旅程</title>
                <description>&lt;p&gt;还记得许多年头的春天，那时的我还没剪去长发，没有信用卡也有没有空，没有 24 小时热水的家。可是当时的我是那么快乐，只有一把破土吉他……&lt;/p&gt;

</description>
                <link>http://birdor.github.io/%E6%97%85%E8%A1%8C/2014/07/%E6%97%85%E8%A1%8C%E5%BF%AB%E4%B9%90</link>
                <guid>http://birdor.github.io/%E6%97%85%E8%A1%8C/2014/07/旅行快乐</guid>
                <pubDate>2014-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>hello world.</title>
                <description>
</description>
                <link>http://birdor.github.io/core-samples/sample/2014/07/hello-world</link>
                <guid>http://birdor.github.io/core-samples/sample/2014/07/hello-world</guid>
                <pubDate>2014-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>入手VoCore</title>
                <description>&lt;p&gt;由于项目需要用到RT5350，一个廉价的WiFi片上芯片，在网上搜索相关资料之后，找到了VoCore这个国内的开源项目，一个带用WiFi的硬币大小的Linux计算机。如果感兴趣的话可以了解一下&lt;a href=&quot;http://vonger.cn/&quot;&gt;作者的博客&lt;/a&gt;和&lt;a href=&quot;https://www.indiegogo.com/projects/vocore-a-coin-sized-linux-computer-with-wifi&quot;&gt;相关介绍&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h1 id=&quot;vocore&quot;&gt;什么是VoCore？&lt;/h1&gt;
  &lt;p&gt;VoCore是运行OpenWrt的开源硬件。尽管WIFI, USB, UART, 20+ GPIO一应俱全，但是大小为1英寸（25mm x 25mm）。它提供了很多的接口，比如说10/100M以太网口、USB、UART、I2C、I2S、PCM、JTAG和超过20个的GPIO口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正如你所看到的，VoCore非常地小，接口也非常密，这个版本没有提代外接的天线，直接用贴片的天线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWyLSbrI/medium.jpg&quot; alt=&quot;VoCore正面&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWyMgd04/medium.jpg&quot; alt=&quot;VoCore背面&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下是它的接口/引脚图，接口非常的丰富，使用必须用电烙铁焊上去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DWyLoaQE/RYVJH.png&quot; alt=&quot;VoCore引脚图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作者除了本身的博客之外，不提供其它的资料，所示还是先看看他的博客吧。&lt;/p&gt;
</description>
                <link>http://birdor.github.io/vocore/2014/07/get_vocore</link>
                <guid>http://birdor.github.io/vocore/2014/07/get_vocore</guid>
                <pubDate>2014-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>在jekyll上使用分页</title>
                <description>&lt;p&gt;一个博客不可能只有几篇文章，如果所有文章全部放在一个页面中，在文章不多的情况下也许较为直观，一旦文章数量增加，不仅加大了用户需要加载的数据量，也为用户检索文章造成了障碍，所以基本上每个博客都会有文章的分页。一般的分页都是通过像JSP的模板引擎直接在从数据库中分页取出时生成动态生成页面，或者通过ajax从数据库分页取出传递到前端。但现在github+jekyll是静态的页面，没有数据库。好在jekyll支持分页功能。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;开启分页功能&lt;/h1&gt;

&lt;p&gt;首先我们需要在jekyll中开启分页功能，在jekyll的_config.yml中加入分页配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paginate: 5
paginate_path: &quot;page:num&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行定义了每页的文章数量，而第二行则定义了在分页的结果，比如在/index.html中使用分页，定义为page:num，则第二页的路径将是/page2/index.html，第三页的路径将是/page3/index.html，以此类推。&lt;/p&gt;

&lt;p&gt;需要注意的几个点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分页只在html文件中起作用&lt;/li&gt;
  &lt;li&gt;paginate_path同时定义了需要被分页的文件，本人测试这个叫index.html，具体目录由paginate_path中的路径定义，如果定义的目录没有，则会向上寻找index.html，直到根目录的index.html，具体机制官网上没有详细说，所以还需要进一步实验&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;使用分页&lt;/h1&gt;

&lt;p&gt;只是开启了分页还没有用，我们需要确实使用到首页之中，在首页(/index.html)中添加如下代码：&lt;/p&gt;

&lt;p&gt;这样，jekyll就会根据paginator来进行分页了，被分出来多少页，就会有多少个页面生成。排1-5的文章就在/index.html中了，而排6-10的文章则在/page2/index.html中，依次类推。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;换页&lt;/h1&gt;

&lt;p&gt;只是分页还不够，我们还需要在每个页面上做一个跳转到其他页面的导航，这里需要用到paginator的一些其他属性。&lt;/p&gt;

&lt;p&gt;首先检测总的页数，如果只有一页，自然就不需要分页了。通过paginator的total_pages属性能判断总页数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.total_pages &amp;gt; 1 %}
&amp;lt;!-- 分页代码 --&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要一个跳转到上一页的按钮，这个按钮在第一页不需要显示，通过paginator的previous_page属性来判断是否是第一个页面，使用paginator的previous_page_path来输出上一页的路径，注意在前面添加baseurl，并进行一些必要的字符替换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.previous_page %}
    &amp;lt;a href=&quot;{{ paginator.previous_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;上一页&amp;lt;/a&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着是生成所有页面的按钮，并使当前页按钮无效化，遍历所有页面，使用paginator的page属性来确定当前页，如果是当前页，则按钮无效，否则使用&lt;code&gt;{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}&lt;/code&gt;来将&lt;code&gt;:num&lt;/code&gt;替换成当前页面的数字生成页面路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      &amp;lt;span class=&quot;active&quot;&amp;gt;{{ page }}&amp;lt;/span&amp;gt;
    {% elsif page == 1 %}
      &amp;lt;a href=&quot;{{ &#39;/index.html&#39; | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&amp;gt;{{ page }}&amp;lt;/a&amp;gt;
    {% else %}
      &amp;lt;a href=&quot;{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}&quot;&amp;gt;{{ page }}&amp;lt;/a&amp;gt;
    {% endif %}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后生成一个下一页的按钮，在最后一页不显示，和上一页按钮类似，通过paginator的next_page_path来确定是否还有下一页：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% if paginator.next_page %}
    &amp;lt;a href=&quot;{{ paginator.next_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
{% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个完整的分页导航功能就做好了，效果就和博客主页上的分页效果是一样的。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;jekyll的分页总的来说还算给力，基本的功能可以完成。但是有一些缺陷，就是category，tag的分类分页无法实现，必须通过插件的方式来做。但是github不允许三方插件，所以只能通过一些其他的方式实现了。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;本文转自：&lt;a href=&quot;http://blog.segmentfault.com/skyinlayer/1190000000406015&quot;&gt;http://blog.segmentfault.com/skyinlayer/1190000000406015&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://birdor.github.io/daily/2014/07/pagination_on_jekyll</link>
                <guid>http://birdor.github.io/daily/2014/07/pagination_on_jekyll</guid>
                <pubDate>2014-07-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Win7/Win8.1打开文件夹时假死的解决办法</title>
                <description>&lt;p&gt;在使用Win8/Win8.1操作系统的过程中，可能会遇到打开文件夹假死现象，地址栏的绿色加载条缓慢前进。这种情况一般在打开了存放了大量可执行程序、图片或者视频的文件夹情况下比较常见。&lt;/p&gt;

&lt;h1 id=&quot;windows-defender&quot;&gt;思路一：关闭Windows Defender&lt;/h1&gt;

&lt;p&gt;如果你没有安装第三方防护软件，系统会默认开启自带的Windows Defender的，默认情况下，扫描文件时会占用大量的系统资源并会造成打开文件夹时假死；如果安装有其他防护软件，Windows Defender应该会自己关闭，如果没有关闭在服务中关闭“Windows Defender Service”服务即可。&lt;/p&gt;

&lt;p&gt;如果你只想使用Windows Defender作为基础防护的话，就需要设定特例了：&lt;/p&gt;

&lt;p&gt;打开Windows Defender，点击“设置”选项卡，在左侧就有相对应的例外设置。可以设置某些文件、文件夹作为例外，也可以设置某类型或某进程是不检查的。当然，例外的设置是需要你在可以熟知你所拥有的程序是无害的。在不添加例外的情况下，扫描结果仅对此次开机有效。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;思路二：重启桌面窗口管理器&lt;/h1&gt;

&lt;p&gt;1、按键盘的“Ctrl+Alt+Del”组合键，打开“任务管理器”，在“进程”选下卡找到“桌面窗口管理器”，结束之；&lt;/p&gt;

&lt;p&gt;2、此时桌面会变成只有背景的状态，继续在任务管理器中选择“文件”菜单下的“运行新任务”；&lt;/p&gt;

&lt;p&gt;3、输入“explorer”后回车，系统会重新启动桌面窗口管理器；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.ithome.com/newsuploadfiles/2014/2/20140223_042222_226.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意使用这种方法会将已经打开的文件夹关闭，需要再次打开，如果有没有保存的工作请在操作前请注意保存。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;思路三：关闭文件预览，开启在单独的进程中打开文件夹窗口功能&lt;/h1&gt;

&lt;p&gt;1、在控制面板中找到“文件夹选项”，切换到“查看”选项卡；&lt;/p&gt;

&lt;p&gt;2、在文件夹选项中切换至“查看”选项卡，勾选“始终显示图标，从不显示缩略图”以及“在单独的进程中打开文件夹窗口”。保存并退出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.ithome.com/newsuploadfiles/2014/2/20140223_042239_954.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;思路四：关闭索引，提升响应速率&lt;/h1&gt;

&lt;p&gt;右键目标文件夹，选择“属性”，然后点击“常规”选项卡下的“高级”按钮，在弹出的对话框中取消“除了文件属性外，还允许索引此驱动器文件的内容”前面的对勾。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.ithome.com/newsuploadfiles/2014/2/20140223_042252_543.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于驱动器属性，在“常规”选项卡中，取消对“除了文件属性外，还允许索引此驱动器文件的内容”的勾选（不建议对系统盘执行此操作，会花费较长的时间而且并不一定成功）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.ithome.com/newsuploadfiles/2014/2/20140223_042306_570.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外，根据IT之家网友的反馈，在Windows 8.1 2014 Update（17025）版本中取消了缩略图缓存文件的大小限制，这样如果你出现了因为生成缩略图缓慢的原因导致系统假死，又不想彻底关闭缩略图预览功能的话，不妨等一等，下次再打开相同的文件夹应该不会出现假死的问题了。&lt;/p&gt;

&lt;p&gt;以上就是IT之家小编为大家整理的一些解决Win8/Windows 8.1打开文件夹假死的解决办法，大家可以试试看，若在Windows Vista/Windows7上出现同样的问题，不妨按照原文的思路一试。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;本文章转自：&lt;a href=&quot;http://www.ithome.com/html/win8/73946.htm&quot;&gt;http://www.ithome.com/html/win8/73946.htm&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://birdor.github.io/daily/2014/04/win8_1_open_directory_problem</link>
                <guid>http://birdor.github.io/daily/2014/04/win8_1_open_directory_problem</guid>
                <pubDate>2014-04-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Marvell88W8686的SPI主控接口</title>
                <description>&lt;p&gt;88w8686 是一款低成本、低功耗，支持IEEE 802.11a/g/b MAC/基带/射频(RF)无线局域网标准的片上系统,设计支持IEEE 802.11a/g标准的6、
9、12、18、24、36、48、54M 有效数据速率，和IEEE 802.11 b 标准的1、2、5.5、11 M 数据速率。88w8686 提供IEEE802.11/802.11 b 标准直接序列扩散光谱(DSSS),802.11a/ g 正交频分复用(OFDM)基带调制,媒体访问控制(MAC),CPU,内存,主机接口,直接转换收音机,无线局域网射频(RF）功能相结合的单一集成芯片。&lt;/p&gt;

&lt;p&gt;88w8686 核心功能单元,通过一个高通量互联系统相互连接，如图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184731593&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;88W8686 配备了一个完全集成的射频到基带收发器工作在2.4 GHz 的ISM 的802.11g/b端口WLAN应用和5 GHz的UNII WLA 802.11a的无线电波段的无线电波段。该收发器架构包括Marvell的第二代，专门设计用于手机通信。蜂窝频段发射杂散音，噪音和接收干扰被设计在其中。&lt;/p&gt;

&lt;p&gt;在手机中由于非常低的频谱发射接收频段，设备不会干扰手机接收和发送高
功率移动电话传输信号。为了获得最佳性能，接收路径上集成的LNA 和AGC 增益调整无缝控制基带功能。整个接收路径已超过90 分贝电压增益。&lt;/p&gt;

&lt;p&gt;综合发射机正交基带信号转换，然后为2.4 GHz 和5 GHz 无线电频带传输提供外部功率放大器的RF 信号。&lt;/p&gt;

&lt;p&gt;本振频率产生一个完全集成的可编程频率合成器，无需任何外部元件。环路
带宽优化相位噪声和动态效能集中在该芯片上。出于安全考虑，88W8686 支持IEEE 802.11i 安全标准，通过实施高级加密标准（AES）/计数器模式CBC - MAC 协议（CCMP），有线等效保密（WEP）临时密钥完整性协议（TKIP）安全机制。为视频，语音，和多媒体应用，88W8686 支持802.11e 的质量服务（QoS）。还支持蓝牙共存接口。88W8686 支持一个通用的SPI（G - SPI）和SDIO 主机接口，采用QFN 封装或倒装芯片封装。&lt;/p&gt;

&lt;h1 id=&quot;w8686-g-spi&quot;&gt;88W8686 G-SPI主控接口&lt;/h1&gt;

&lt;p&gt;88W8686&lt;em&gt;主机接口单元(Host Interface Unit,HIU)&lt;/em&gt;连接几个主机接口总线单元到设备(指88W8686)的内部总线上。每个HIU和其他HIU是通过共享到内部总线的连接，但88W8686每次只允许一个HIU被激活。&lt;/p&gt;

&lt;p&gt;88W8686的HIU支持G-SPI(通用的SPI)接口和SDIO接口。它支持一个通用的、半双工(half-duplex)、DMA辅助(DMA-assisted)的SPI接口，允许一个主控制器使用通用的SPI协议来访问WLAN设备(指88W8686)。G-SPI接口包含了外部SPI总线和内部共享总线之间的接口电路，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184736000&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;88W8686在SPI总线上表示为设备，主机单元能够直接访问G-SPI寄存器和通过使用BARs(Base Address Register，基地址寄存器)和DMA引擎来访问设备的共享内存。&lt;/p&gt;

&lt;p&gt;SPI单元支持通用的SPI接口协议，工作速率可达50MHz，此接口支持下面的功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SPI单元总线设备操作&lt;/li&gt;
  &lt;li&gt;SPI单元寄存器读写&lt;/li&gt;
  &lt;li&gt;对内部CPU产生中断&lt;/li&gt;
  &lt;li&gt;对外部SPI主控制器产生中断(比如S3C2451的SPI控制器)&lt;/li&gt;
  &lt;li&gt;通过DMA访问内部共享内存&lt;/li&gt;
  &lt;li&gt;对电源管理单元产生唤醒中断&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;g-spi&quot;&gt;G-SPI接口信号描述&lt;/h1&gt;

&lt;p&gt;88W8686复位后，紧接着使用下面配置输入引脚来设置参数，但是在88W8686复位到一定时间之后，这些引脚立刻改为变他们通常的功能，比如GPIO[5]就作为通常的功能使用。如果要设置一个配置位为0，通过连接一个阻值为100 kΩ的下拉电阻，比如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184739406&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果要设置一个配置位为1，则不需要接外部电路&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184743000&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;88W8686的配置引脚如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184747203&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来看G-SPI接口引脚的说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184751296&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;g-spi-1&quot;&gt;G-SPI接口功能描述&lt;/h1&gt;

&lt;p&gt;G-SPI接口的标准G-SPI物理总线上支持多种简单的地址/数据协议，这些协议通过地址的位数和数据的顺序来区分。&lt;/p&gt;

&lt;p&gt;每次通讯由主机通过拉低SCSn信号来发起，从机在检测到SCSn有效(低电平)之后，在每个SCLK的上升沿锁存SDI引脚上输入的数据。当从机要输出数据时，在SCLK的下降沿送出数据。SCLK输入信号在每次通讯的开始和结束都为低电平，中断输入信号SINTn由设备发送给主机(比如S3C2451的SPI主控制器)&lt;/p&gt;

&lt;h2 id=&quot;transaction-delay&quot;&gt;通讯时延(transaction delay)&lt;/h2&gt;

&lt;p&gt;第一个数据块是从主机发送到设备(从机)的，这个数据块包含一个地址和读/写标志，地址的最高位(MSB)如果为0表示读，如果为1表示写。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;写操作时延(write Write Transaction Delay)
 &amp;gt;对于写操作，写操作的数据段紧跟着地址段，地址和数据段之间，不需要主机产生低时钟脉冲。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读操作时延(read Write Transaction Delay)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;读操作时，在总线上地址段之后和数据段之前要求有一些时延。这些时延表现为*TDDR(time delay read register，读寄存器时延)*和*TDRP(timedelay read port，读端口时延)*，这些时延表示设备需要需要一些时间来准备有效数据给主机。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有两种方式来建立这些时延：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一种：主机通过发送一定数量的&lt;em&gt;虚拟时钟周期(a known number of dummyclock cycles)&lt;/em&gt;到设备来创建读操作时延，这些虚拟时钟周期定义在&lt;em&gt;延迟读寄存器(delay readregister)&lt;/em&gt;中，也就是说主机要发送的&lt;em&gt;虚拟时钟周期&lt;/em&gt;数量由&lt;em&gt;延迟读寄存器&lt;/em&gt;的值来定，下面来看此寄存器的定义：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184755281&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上图可知&lt;em&gt;Delay Method&lt;/em&gt;的值由&lt;em&gt;SPU Bus Mode寄存器&lt;/em&gt;(&lt;code&gt;offset 0x70[2]=1&lt;/code&gt;)的&lt;em&gt;Delay_Method&lt;/em&gt;位的值来决定，下面来看此寄存器的定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184803765&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SPU(SPI host interface unit)表示SPI主机接口单元。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第二种：通过主机在地址段和数据段之间保持(holding)低时钟信号至少一段时间来创建读操作时延(the delay is created bythe host holding the clock signal low for a minimum period of time between the addressand data phases)，此模式通过设置&lt;code&gt;0x70[2]=0&lt;/code&gt;来选择。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在读操作的数据段区间，主机继续提供时钟脉冲和同时驱动数据到SDI输入引脚或从SDO输出引脚读取数据。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;数据传输&lt;/h2&gt;

&lt;p&gt;主机经常访问G-SPI单元的配置寄存器，为了访问内部内存空间，一些寄存器被定义为端口寄存器。当访问端口寄存器时，从机使用相应的基地址寄存器(BAR)和DMA引擎来从内部内存空间读取数据，或是写入数据内部内存空间。&lt;/p&gt;

&lt;p&gt;主机和从机间的每一次传输都是&lt;em&gt;突发模式&lt;/em&gt;(一个地址后面跟着多个数据)，在读或写完所要求数量的数据后，主机通过拉高SCSn引脚来结束此次传输。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;端口寄存器访问&lt;/h3&gt;

&lt;p&gt;主机读&lt;em&gt;端口寄存器&lt;/em&gt;时，对于&lt;em&gt;突发模式&lt;/em&gt;的数据长度没有限制(除了内部总线的有效地址范围限制之外)。主机写端口寄存器时，对&lt;em&gt;突发模式&lt;/em&gt;的数据长度唯一要求是：长度是DWORDS的倍数。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;端口寄存器&lt;/em&gt;(I/O端口，命令端口，数据端口)被用来访问内部32-bit存储空间和总是32-bit对齐访问。每个端口寄存器都有一个相应的BAR用来读写(BAR作为一个指针指向要读写的内存空间的开始物理地址)。内存也只能32-bit对齐访问，这通过向相应的BAR写入32-bit对齐的数据来是实现，在访问期间，第16bits数据总线最先出现在总线上。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;写数据到端口寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;写数据到端口寄存器，就是依次填满起始位置在BAR的连续的32-bit内存空间。当从从机的数据和命令端口读数据时，DMA引擎连续填充FIFO知道剩余空间不足8个DWORDs。当写数据到设备时，拉高SCSn信号脚来清空FIFO。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;从端口寄存器读数据&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;当从设备的I/O端口读数据时，可以选择DMA引擎是执行单一读或是突发模式读。突发模式读与读端口和命令端口一样，单一模式读让DMA引擎在内部总线上指向单个DWORD访问。单一模式读通讯必须在返回数据的第一或是第二个16-bit块之后终止。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;配置寄存器访问&lt;/h3&gt;

&lt;p&gt;当主机访问端口寄存器之外的其他寄存器时，突发模式长度必须限制在一个16-bit的数，或是如果地址是以DWORD边界对齐的两个16-bit数。当内部总线的单元访问G-SPI接口寄存器，则必须是单个DWORD或是更小来访问。&lt;/p&gt;

&lt;p&gt;G-SPI除了端口寄存器之外的接口寄存器，都能以16-bit边界对齐的方式读或是写。当单个16-bit word被读出或写入，通讯可以被终止。&lt;/p&gt;

&lt;h2 id=&quot;g-si&quot;&gt;G-SI时钟频率&lt;/h2&gt;

&lt;p&gt;G-SPI时钟频率不能大于内部总线时钟频率的2.5倍，内部总线时钟频率&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184803765&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;数据格式&lt;/h2&gt;

&lt;p&gt;总共有16个有效数据格式，下面9个数据格式是可用的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有4读数据格式，在地址段和数据段之间的延迟时间，时钟信号保持为低电平。&lt;/li&gt;
  &lt;li&gt;所有4个写数据格式。&lt;/li&gt;
  &lt;li&gt;1个读数据格式，在地址段和数据段之间的延迟时间，时钟信号切换为固定数量的周期。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每种读写操作类型都有两种地址长度，要么是8-bit要么是16-bit，而每种地址长度对应有两种数据顺序。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;可编程的时钟周期延迟&lt;/h3&gt;

&lt;p&gt;下面是&lt;code&gt;Delay_Method=0&lt;/code&gt;的读数据格式，在这种模式下，&lt;code&gt;tdr(r/p)&lt;/code&gt;的值代表最后一个地址位和第一个数据位之间的延时时间，这段时间内时钟信号SCLK保持为低电平。有两个不同的延时值，包括从G-SPI配置寄存器读取的值和从G-SPI端口寄存器读取的值。一旦读写操作指定的时延期满，有效的数据就从设备中发出。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读数据格式&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;![](http://img.blog.csdn.net/20130609184808203)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;写数据格式&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;![](http://img.blog.csdn.net/20130609184812765) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;固定的时钟周期延迟&lt;/h3&gt;

&lt;p&gt;下面是读数据格式的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184816609&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;目前我们G-SPI驱动读数据格式就是采用这种格式。&lt;/p&gt;

&lt;h2 id=&quot;g-spi-2&quot;&gt;G-SPI接口寄存器内存空间&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130609184820203&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;本文章转自：&lt;a href=&quot;http://blog.csdn.net/loongembedded/article/details/9067013&quot;&gt;http://blog.csdn.net/loongembedded/article/details/9067013&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
                <link>http://birdor.github.io/embedded/2014/04/Marvell88W8686_SPI_Interface</link>
                <guid>http://birdor.github.io/embedded/2014/04/Marvell88W8686_SPI_Interface</guid>
                <pubDate>2014-04-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>批量删除Kindle云端的个人文档</title>
                <description>&lt;p&gt;在使用Kindle的推送时，有一个不好的地方就是，推送的电子书会被放到云端，而且要删除的话不能批量删，长年累月就积累了一大批。本人找到一种方法可以批量删除当前&lt;em&gt;个人文档&lt;/em&gt;页面的电子书。&lt;/p&gt;

&lt;p&gt;首先，登录&lt;em&gt;amazon&lt;/em&gt;，并点击个人文档，将以下代码复制进地址栏中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javascript:(function(){ var v = new RegExp(&quot;PersonalDocuments&quot;); if (!v.test(document.URL)) { return false; } {a=document.getElementsByClassName(&#39;rowBodyCollapsed&#39;);for(var i = 0; i&amp;lt;a.length; i++){Fion.deleteItem(&#39;deleteItem_&#39;+a[i].getAttribute(&#39;asin&#39;));};return; }})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按回车后，便会删除当前页面的电子书。当然，你也可以在搜索框搜索电子书，再输入以上代码删除搜索结果页面的电子书。&lt;/p&gt;

&lt;p&gt;这里有一个要注意的地方，如果你使用的浏览器是&lt;em&gt;chrome&lt;/em&gt;的话，以上代码复制进地址栏时，&lt;em&gt;javascript&lt;/em&gt;这个关键字会被注释掉，可以复制进地址栏之后，再在前面添加&lt;em&gt;javascript&lt;/em&gt;关键字。当然，你也可以按&lt;em&gt;F12&lt;/em&gt;进入打开&lt;em&gt;开发者工具&lt;/em&gt;，再点击&lt;em&gt;Console&lt;/em&gt;,再输入以上代码。&lt;/p&gt;
</description>
                <link>http://birdor.github.io/daily/2014/04/delete_document_on_kindle_cloud</link>
                <guid>http://birdor.github.io/daily/2014/04/delete_document_on_kindle_cloud</guid>
                <pubDate>2014-04-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>sk_buff结构分析</title>
                <description>&lt;p&gt;在wlan驱动中，数据读取写入是通过&lt;code&gt;sk_buff&lt;/code&gt;这个结构体，而&lt;code&gt;sk_buff&lt;/code&gt;结构主要作用是包含接收的缓冲数据，和它的包头信息。如下是&lt;code&gt;sk_buff&lt;/code&gt;的主要结构成员：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct sk_buff {
...
	unsigned char *head;
	unsigned char *data;
	unsigned char *tail;
	unsigned char *end;
...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;sk_buff&lt;/code&gt;还包含一些链表的东西，在此处并不做解析。在以上结构体中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;head&lt;/code&gt;：报文缓冲区的头；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;data&lt;/code&gt;：数据的头指针；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;tail&lt;/code&gt;：数据的尾指针；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;end&lt;/code&gt; ：报文缓冲区的尾部。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如图所示，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDM9tAj/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分别有三个空间：&lt;em&gt;head room&lt;/em&gt;、&lt;em&gt;packet data&lt;/em&gt;、&lt;em&gt;tail room&lt;/em&gt;。其中&lt;em&gt;packet data&lt;/em&gt;是数据所在区包括数据的包头，&lt;em&gt;head room&lt;/em&gt;是数据头部增长的预留空间、&lt;em&gt;tail room&lt;/em&gt;是尾部增加的空间。预留头部使用&lt;code&gt;skb_reserve(skb, header_len);&lt;/code&gt;函数，尾部增加使用&lt;code&gt;skb_put()&lt;/code&gt;，头部增长使用&lt;code&gt;skb_push()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以下图是调用分配空间函数，即初始化函数&lt;code&gt;alloc_skb(len, GFP_KERNEL)&lt;/code&gt;的样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDLzyp1/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，&lt;code&gt;head&lt;/code&gt;、&lt;code&gt;data&lt;/code&gt;和&lt;code&gt;tail&lt;/code&gt;都指向了缓冲区的起始，而end指向结束。这个SKB的数据长度为0，不包含任何数据。&lt;/p&gt;

&lt;p&gt;接着调用了&lt;code&gt;skb_reserve(skb, header_len)&lt;/code&gt;预留了头部数据，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDM9eQx/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过调用&lt;code&gt;skb_put()&lt;/code&gt;向尾部增长数据，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDM9fX0/medish.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过调用&lt;code&gt;skb_push()&lt;/code&gt;向头部增长数据，如图所示，增加了一个UDP头：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/simpleyyt/DGDM8T7V/medium.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本文考参：&lt;a href=&quot;http://vger.kernel.org/~davem/skb_data.html&quot;&gt;http://vger.kernel.org/~davem/skb_data.html&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://birdor.github.io/linux/2014/04/sk_buff_analysis</link>
                <guid>http://birdor.github.io/linux/2014/04/sk_buff_analysis</guid>
                <pubDate>2014-04-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>QF9700 Linux 3.0.8驱动补丁</title>
                <description>&lt;p&gt;网上有QF9700/RD9700的开源驱动，&lt;a href=&quot;http://www.elite.uk.com/mike/qf9700/&quot;&gt;点此下载&lt;/a&gt;。但是最高只支持Linux 2.6.32，在Linux 3.0.8编译下会出现错误，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Building QF9700 USB2NET chip driver...
make[1]: 正在进入目录 `/home/snail/文档/Project/FriendlyArm/linux-3.0.8&#39;
  CC [M]  /home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.o
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c: In function &#39;qf9700_set_multicast&#39;:
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:356:45: error: &#39;struct net_device&#39; has no member named &#39;mc_count&#39;
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:358:16: error: &#39;struct net_device&#39; has no member named &#39;mc_count&#39;
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:359:36: error: &#39;struct net_device&#39; has no member named &#39;mc_list&#39;
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:362:22: error: &#39;struct net_device&#39; has no member named &#39;mc_count&#39;
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:362:56: error: dereferencing pointer to incomplete type
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:363:14: error: dereferencing pointer to incomplete type
make[2]: *** [/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.o] 错误 1
make[1]: *** [_module_/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700] 错误 2
make[1]:正在离开目录 `/home/snail/文档/Project/FriendlyArm/linux-3.0.8&#39;
make: *** [all] 错误 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为此，写了一个补丁。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff -ur b/qf9700.c a/qf9700.c
--- b/qf9700.c	2011-01-21 17:59:58.000000000 +0800
+++ a/qf9700.c	2014-04-15 18:37:50.000000000 +0800
@@ -353,14 +353,13 @@
 
 	if (net-&amp;gt;flags &amp;amp; IFF_PROMISC) {
 		rx_ctl |= 0x02;
-	} else if (net-&amp;gt;flags &amp;amp; IFF_ALLMULTI || net-&amp;gt;mc_count &amp;gt; QF_MCAST_MAX) {
+	} else if (net-&amp;gt;flags &amp;amp; IFF_ALLMULTI || netdev_mc_count(net) &amp;gt; QF_MCAST_MAX) {
 		rx_ctl |= 0x04;
-	} else if (net-&amp;gt;mc_count) {
-		struct dev_mc_list *mc_list = net-&amp;gt;mc_list;
-		int i;
+	} else if (netdev_mc_count(net)) {
+		struct netdev_hw_addr *hw_addr;
 
-		for (i = 0; i &amp;lt; net-&amp;gt;mc_count; i++, mc_list = mc_list-&amp;gt;next) {
-			u32 crc = ether_crc(ETH_ALEN, mc_list-&amp;gt;dmi_addr) &amp;gt;&amp;gt; 26;
+		netdev_for_each_mc_addr(hw_addr, net) {
+			u32 crc = ether_crc(ETH_ALEN, hw_addr-&amp;gt;addr) &amp;gt;&amp;gt; 26;
 			hashes[crc &amp;gt;&amp;gt; 3] |= 1 &amp;lt;&amp;lt; (crc &amp;amp; 0x7);
 		}
 	}
@@ -413,9 +412,9 @@
 
 	/* power up and reset phy */
 	qf_write_reg(dev, PRR, 1);
-	udelay(20 * 1000);	// at least 10ms, here 20ms for safe
+	mdelay(20);	// at least 10ms, here 20ms for safe
 	qf_write_reg(dev, PRR, 0);
-	udelay(2 * 1000);	// at least 1ms, here 2ms for reading right register
+	mdelay(2);	// at least 1ms, here 2ms for reading right register
 
 	/* receive broadcast packets */
 	qf9700_set_multicast(dev-&amp;gt;net);
diff -ur b/qf9700.h a/qf9700.h
--- b/qf9700.h	2010-10-09 16:51:00.000000000 +0800
+++ a/qf9700.h	2014-04-15 17:20:23.000000000 +0800
@@ -150,4 +150,21 @@
 #define	QF_TX_OVERHEAD		2	// 2bytes header
 #define	QF_RX_OVERHEAD		7	// 3bytes header + 4crc tail
 
+#ifdef DEBUG
+#define devdbg(usbnet, fmt, arg...) \
+        printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+#else
+#define devdbg(usbnet, fmt, arg...) \
+        ({ if (0) printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , \
+                ## arg); 0; })
+#endif
+
+#define deverr(usbnet, fmt, arg...) \
+        printk(KERN_ERR &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+#define devwarn(usbnet, fmt, arg...) \
+        printk(KERN_WARNING &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+
+#define devinfo(usbnet, fmt, arg...) \
+        printk(KERN_INFO &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg); \
+
 /*----------------------------------------------------------------------------------------------*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://pan.baidu.com/s/1sjKysEx&quot;&gt;点此&lt;/a&gt;下载源文件及补丁文件。&lt;/p&gt;
</description>
                <link>http://birdor.github.io/linux/2014/04/qf9700_for_linux_3.0.8</link>
                <guid>http://birdor.github.io/linux/2014/04/qf9700_for_linux_3.0.8</guid>
                <pubDate>2014-04-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Marvel 88w8686 Linux驱动分析</title>
                <description>&lt;p&gt;由于编写Marvel 88w8686 wlan模块SPI接口的&lt;em&gt;stm32&lt;/em&gt;驱动的需要，对&lt;a href=&quot;http://pan.baidu.com/s/1dDiSZFb&quot;&gt;Marvel 88w8686 Linux&lt;/a&gt; SPI接口的驱动进行了分析和参考。&lt;/p&gt;

&lt;h1 id=&quot;marvel&quot;&gt;Marvel驱动的使用&lt;/h1&gt;

&lt;p&gt;88w8686的Linux驱动是通过模块方式载入内核的，在使用时加载进去就行了，88w8686的Linux驱动还包含了sdio的驱动，加载时，还必须加载sdio驱动。在运行&lt;code&gt;make&lt;/code&gt;命令进行编译后，会生成&lt;code&gt;sdio.o&lt;/code&gt;和&lt;code&gt;sd8386.o&lt;/code&gt;文件，在终端下输入下列命令进行加载：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insmod sdio.o
insmod sd8385.o
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;marvel-1&quot;&gt;Marvel驱动源码分析&lt;/h1&gt;

&lt;p&gt;了解完如何使用Marvel 88w8686 Linux驱动后，便可以进行驱动源码的分析。源码&lt;a href=&quot;http://pan.baidu.com/s/1dDiSZFb&quot;&gt;点击此处&lt;/a&gt;下载。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;源码目录结构&lt;/h2&gt;

&lt;p&gt;源码的目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├─app
│  └─wlanconfig
├─config
├─if
│  └─if_gspi
├─io
│  └─gspi
│      └─pxa270
├─os
│  └─linux
└─wlan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;em&gt;app文件夹&lt;/em&gt;是驱动自带的wlanconfig工具，用于配置wifi的参数，本文不进行分析。&lt;em&gt;config文件夹&lt;/em&gt;包含的是一些配置文件，不进行分析。if文件夹包含的是关于GSPI操作的接口，包括固件。&lt;em&gt;io文件夹&lt;/em&gt;包含的是GSPI驱动。&lt;em&gt;os文件夹&lt;/em&gt;包含的是与系统相关的操作与头文件。&lt;em&gt;wlan文件夹&lt;/em&gt;是wifi驱动的主要目录，在本文进行重点分析。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;驱动的启动流程&lt;/h2&gt;

&lt;p&gt;由上文可知，wlan驱动是通过&lt;code&gt;insmod&lt;/code&gt;进加载的。在文件&lt;code&gt;wlan/wlan_main.c&lt;/code&gt;末尾处可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module_init(wlan_init_module);
module_exit(wlan_cleanup_module);

MODULE_DESCRIPTION(&quot;M-WLAN Driver&quot;);
MODULE_AUTHOR(&quot;Marvell International Ltd.&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这几个宏说明了wlan驱动模块的入口，知道其初始化函数是&lt;code&gt;wlan_init_module&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;再来看看&lt;code&gt;wlan_init_module&lt;/code&gt;函数，在其函数中，调用了以下函数对网卡插入和移除时调用的函数进行了注册，即当电脑检测到网卡时有调用&lt;code&gt;wlan_add_card&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sbi_register(wlan_add_card, wlan_remove_card, NULL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;wlan_add_card&lt;/code&gt;中，进行初始化后，以下函数启动了内核主线程&lt;code&gt;wlan_service_main_thread&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wlan_create_thread(wlan_service_main_thread, &amp;amp;priv-&amp;gt;MainThread, &quot;wlan_main_service&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;内核主线程&lt;/h3&gt;

&lt;p&gt;内核主线程&lt;code&gt;wlan_service_main_thread&lt;/code&gt;承担了wlan驱动的主要工作，它主要是处理wlan固件的事件，wlan固件接受到的数据和内核传来的数据。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;wlan_service_main_thread&lt;/code&gt;函数中有一个&lt;code&gt;for&lt;/code&gt;死循环，所有数据处理都在循环里面。&lt;/p&gt;

&lt;p&gt;在主循环里面，首先调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
...
schedule();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让主线程进入可中断的等待模式，等到事件到来。当主线程被唤醒时，即有数据要处理，便调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sbi_get_int_status(priv, &amp;amp;ireg)；
...
Adapter-&amp;gt;HisRegCpy |= ireg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先读取网卡固件发来的数据及标志位，将标志位存入&lt;code&gt;Adapter-&amp;gt;HisRegCpy&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;紧接着便对标志位进行判断：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Command response? */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_CmdUpLdRdy) {
	PRINTM(INFO, &quot;main-thread: Cmd response ready.\n&quot;);

	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_CmdUpLdRdy;
	OS_INT_RESTORE;

	wlan_process_rx_command(priv);
}

/* Any received data? */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_RxUpLdRdy) {
	PRINTM(INFO, &quot;main-thread: Rx Packet ready.\n&quot;);
	
	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_RxUpLdRdy;
	OS_INT_RESTORE;

	wlan_send_rxskbQ(priv);
}

/* Any Card Event */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_CardEvent) {
	PRINTM(INFO, &quot;main-thread: Card Event Activity.\n&quot;);

	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_CardEvent;
	OS_INT_RESTORE;

	if (sbi_read_event_cause(priv)) {
		PRINTM(MSG, &quot;main-thread: sbi_read_event_cause failed.\n&quot;);
		continue;
	}
	wlan_process_event(priv);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且调用相应的处理函数，对数据进行处理。&lt;/p&gt;

&lt;p&gt;当然进程中还对wlan的PS（Power Save）模式和WMM（WiFi-MultiMedia）进行判断处理，本文不进行分析。&lt;/p&gt;

&lt;p&gt;接着，便对内核发来的命令进行处理（比如说连接命令，扫描命令）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Execute the next command */
if (!priv-&amp;gt;wlan_dev.dnld_sent &amp;amp;&amp;amp; !Adapter-&amp;gt;CurCmd) {
	ExecuteNextCommand(priv);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，之后便进入等待事件状态，重复以上过程。&lt;/p&gt;

&lt;h3 id=&quot;wlan&quot;&gt;wlan固件数据/事件&lt;/h3&gt;

&lt;p&gt;当wlan固件有数据/事件时，GSPI驱动会产生中断，它的中断处理函数为&lt;code&gt;sbi_interrupt&lt;/code&gt;，在&lt;code&gt;sbi_interrupt&lt;/code&gt;中调用了&lt;code&gt;wlan_interrupt&lt;/code&gt;,在&lt;code&gt;wlan_interrupt&lt;/code&gt;中，调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wake_up_interruptible(&amp;amp;priv-&amp;gt;MainThread.waitQ);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唤醒了主线程，对数据进行处理。上面介绍过，主线程调用&lt;code&gt;sbi_get_int_status(priv, &amp;amp;ireg)&lt;/code&gt;读取数据和标志位。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;应用层调用驱动接口&lt;/h3&gt;

&lt;p&gt;该wlan驱动接口是wext（Wireless Extensions无线扩展接口）。wext的接口实现上，应用层采用ioctl方式访问驱动，设置无线参数或者获取无线参数，配置无线驱动进行联网操作。无线驱动事件到应用层的传递采用的netlink socket技术，一种netlink route消息技术。这也是很多其他类型的驱动标准的实现方法。具体调用方法可以参考&lt;code&gt;wlanconfig&lt;/code&gt;，比如说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ioctl(sockfd, SIOCGIWSCAN, &amp;amp;iwr));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用wlan驱动扫描命令。如下函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s = socket(PF_INET, SOCK_DGRAM, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建了一个netlink连接。&lt;/p&gt;

&lt;p&gt;所有的ioctl的回调函数在，wlan_wext.c的&lt;code&gt;wlan_handler&lt;/code&gt;数组中，这里对&lt;code&gt;SIOCGIWSCAN&lt;/code&gt;即wlan扫描进行分析。可以看到wlan扫描的回调函数是&lt;code&gt;wlan_get_scan&lt;/code&gt;和&lt;code&gt;wlan_set_scan&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;先来看看&lt;code&gt;wlan_set_scan&lt;/code&gt;，在&lt;code&gt;wlan_set_scan&lt;/code&gt;函数中又调用了&lt;code&gt;wlan_scan_networks&lt;/code&gt;,在&lt;code&gt;wlan_scan_networks&lt;/code&gt;中调用了&lt;code&gt;wlan_scan_channel_list&lt;/code&gt;将命令添加到命令队列中，并等待命令执行响应，然后调用&lt;code&gt;wlan_scan_process_results&lt;/code&gt;更新&lt;code&gt;priv&lt;/code&gt;中的扫描表。&lt;/p&gt;

&lt;p&gt;在函数&lt;code&gt;wlan_scan_channel_list&lt;/code&gt;中调用&lt;code&gt;PrepareAndSendCommand&lt;/code&gt;将命令添加到命令列表。等发送到固件的数据和固件发送过来的数据都存在&lt;code&gt;CmdNode-&amp;gt;BufVirtualAddr&lt;/code&gt;指针指向的数据中，接着调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QueueCmd(Adapter, CmdNode, TRUE);
wake_up_interruptible(&amp;amp;priv-&amp;gt;MainThread.waitQ);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将命令加入命令队列，接着唤醒主线程处理命令，然后执行如下函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wait_event_interruptible(CmdNode-&amp;gt;cmdwait_q, CmdNode-&amp;gt;CmdWaitQWoken);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待结果，当&lt;code&gt;CmdNode-&amp;gt;CmdWaitQWoken&lt;/code&gt;为&lt;code&gt;TRUE&lt;/code&gt;时唤醒。&lt;/p&gt;

&lt;p&gt;在主线程中，由上面知道，调用&lt;code&gt;ExecuteNextCommand&lt;/code&gt;执行内核发来的命令。在&lt;code&gt;ExecuteNextCommand&lt;/code&gt;函数中调用&lt;code&gt;DownloadCommandToStation&lt;/code&gt;下载命令，&lt;code&gt;DownloadCommandToStation&lt;/code&gt;中，先调用&lt;code&gt;sbi_host_to_card&lt;/code&gt;下载命令，然后调用&lt;code&gt;ModTimer&lt;/code&gt;进行超时时重新发送。&lt;/p&gt;

&lt;p&gt;接下来，便是等待响应，当固件对发来的命令响应时，会触发中断，如上文说的调用&lt;code&gt;wlan_process_rx_command&lt;/code&gt;处理固件对命令的响应。在&lt;code&gt;wlan_process_rx_command&lt;/code&gt;中处理完成之后，会调用&lt;code&gt;CleanupAndInsertCmd&lt;/code&gt;回收命令，此时的&lt;code&gt;CmdNode-&amp;gt;CmdWaitQWoken&lt;/code&gt;为&lt;code&gt;TRUE&lt;/code&gt;，下次&lt;code&gt;schedule&lt;/code&gt;时便，唤醒上面等待命令响应的线程，让其继续执行。&lt;/p&gt;

&lt;p&gt;整个驱动运行的流程便是这样子。&lt;/p&gt;
</description>
                <link>http://birdor.github.io/embedded/2014/04/marvel_88w8686_wifi_linux_driver_analysis</link>
                <guid>http://birdor.github.io/embedded/2014/04/marvel_88w8686_wifi_linux_driver_analysis</guid>
                <pubDate>2014-04-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>强化你的Terminal IDE——在android平板/手机上编写C/C++</title>
                <description>&lt;p&gt;&lt;a href=&quot;http://code.google.com/p/terminal-ide/downloads/list&quot;&gt;Terminal IDE&lt;/a&gt;是一个可扩展的终端应用，其包含了全功能的Java/HTML/Android开发套件。Terminal IDE集成了VIM, ssh, git等多个功能，其中强大之处，大家自己发觉，如果你用惯了Linux下的shell命令，那么用Terminal IDE你将会得心应手，喜欢上它的。&lt;/p&gt;

&lt;p&gt;虽然Terminal IDE很强大，可以编写Java，android，但它没有gcc/g++。没关系，Terminal IDE强大之处就在于它是可拓展的，具体可以看它的Help。此处，我说明一下，如何把gcc/g++加入Terminal IDE，其实就是将linux-arm-gcc加入Terminal IDE 。 &lt;/p&gt;

&lt;p&gt;首先，将&lt;a href=&quot;http://www.kuaipan.cn/file/id_41572487401570322.htm&quot;&gt;linux-arm-gcc&lt;/a&gt;解压到Terminal IDE中的&lt;code&gt;~/system&lt;/code&gt;目录下(不是系统的&lt;code&gt;/system/&lt;/code&gt;，其真正目录为:&lt;code&gt;data/data/com.spartacusrex.spartacuside/files/system&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;修改该’gcc’目录为可读写，在Terminal IDE下执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod -R 777 ./gcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改&lt;code&gt;~&lt;/code&gt;(即&lt;code&gt;data/data/com.spartacusrex.spartacuside/files/&lt;/code&gt;)目录下的&lt;code&gt;.bashrc&lt;/code&gt;文件。添加需要的环境变量，在&lt;code&gt;~/.bashrc&lt;/code&gt;文件添加如下环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export CPLUS_INCLUDE_PATH=$IDESYSTEM/gcc/arm-linux-androideabi/c++/include:$CPLUS_INCLUDE_PATH
export C_INCLUDE_PATH=$IDESYSTEM/gcc/arm-linux-androideabi/include:$C_INCLUDE_PATH
export PATH=$IDESYSTEM/gcc/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;gcc/bin&lt;/code&gt;下的相应文件改一下名，改为&lt;code&gt;gcc&lt;/code&gt;和&lt;code&gt;g++&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;再重启Terminal IDE后(需按TerminalIDE的Shutdown按钮)，便可以使用gcc和g++进行c++/c的编译，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim a.cpp   //写入代吗
g++ a.cpp   //编译
./a.out     //运行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，再用otg接个键盘或者用蓝牙键盘的话，那么整个apad就相当于你的电脑，得心应手。&lt;/p&gt;

&lt;p&gt;如果你熟悉Linux和vim，以上方法是不错的选择，如果不熟悉的话，可以用C4droid。这里在贴出几个工具：（下载地址可以自己搜，我只贴出GooglePlay上的地址。）&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.aide.ui&amp;amp;hl=en&quot;&gt;AIDE&lt;/a&gt;：可以在android平板/手机上编写android应用，编译后可直接安装。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.n0n3m4.droidc&amp;amp;hl=en&quot;&gt;C4droid&lt;/a&gt;：可以在android平板/手机上编写并编译c/c++，不过不够强大。但比较容易安装。&lt;/p&gt;

&lt;p&gt;　　ADDI：可以在android平板/手机上执行少量的matlab指令。&lt;/p&gt;

&lt;p&gt;以上适合apad+键盘，如果没有键盘的话，我觉得还是别折腾了，没有这个必要吧。写一写小程序还是可以的，大的项目就不行了，编译会很慢的。&lt;/p&gt;
</description>
                <link>http://birdor.github.io/android/2012/11/c_on_android</link>
                <guid>http://birdor.github.io/android/2012/11/c_on_android</guid>
                <pubDate>2012-11-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Jekyll Introduction</title>
                <description>
&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we’ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;h3 id=&quot;what-is-jekyll&quot;&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as “a simple, blog aware, static site generator”.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;what-does-jekyll-do&quot;&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files,
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id=&quot;jekyll-is-not-blogging-software&quot;&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id=&quot;why-should-i-care&quot;&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
  &lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
  &lt;li&gt;No internet connection required.&lt;/li&gt;
  &lt;li&gt;Ability to publish via git.&lt;/li&gt;
  &lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
  &lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
  &lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-jekyll-works&quot;&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id=&quot;initial-setup&quot;&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you’ll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id=&quot;the-jekyll-application-base-format&quot;&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 2011-10-25-open-source-is-good.markdown
|   |-- 2011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;
  Stores configuration data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;
  This folder is for partial views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt;
  This folder is for the main templates your content will be inserted into.
  You can have different layouts for different pages or page sections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;
  This folder contains your dynamic content/posts.
  the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;
  This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;
  This folder is not part of the standard jekyll structure.
  The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
  Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;jekyll-configuration&quot;&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here:
(&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;content-in-jekyll&quot;&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content “objects” get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id=&quot;posts-and-pages&quot;&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id=&quot;working-with-posts&quot;&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory.
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post’s YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy “set”.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy “lessons/beginner”. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won’t find “lessons” and “beginner” as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id=&quot;working-with-pages&quot;&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;templates-in-jekyll&quot;&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page’s or post’s content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;
Templates should be coded in HTML and contain YAML Front Matter.
All templates can contain Liquid code to work with your site’s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sub-templates&quot;&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they
define another “root” layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id=&quot;includes&quot;&gt;Includes&lt;/h3&gt;
&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id=&quot;using-liquid-for-templating&quot;&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id=&quot;what-is-liquid&quot;&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data.&lt;/p&gt;

&lt;h3 id=&quot;why-do-we-have-to-use-liquid&quot;&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;.
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id=&quot;liquid-is-not-programmer-friendly&quot;&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can’t do jackshit in liquid that hasn’t been allowed explicitly by the implementation.
What’s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll’s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins.
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;
My personal stance is to not invest time trying to hack liquid. It’s really unnecessary
&lt;em&gt;from a programmer’s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I’ve built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-assets&quot;&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-parses-files&quot;&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt;
  This is done with textile or markdown.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;
  These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
  Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id=&quot;formatting-files-for-parsing&quot;&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We’ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;defining-layouts-for-posts-and-templates-parsing&quot;&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you’d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-generates-the-final-static-files&quot;&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll’s job is to generate a static representation of your website.
The following is an outline of how that’s done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt;
  Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt;
  Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one
  big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
  At this stage your site is one big computed ruby object.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;
  Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
  Once the post is parsed and liquified inside the the proper layout structure, the layout itself is “liquified”.
 &lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
  hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt;
 Finally the liquid templates are “rendered”, thereby processing any liquid syntax provided in the templates
 and saving the final, static representation of the file.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you’ll iterate through and format
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
  &lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at []()
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you’d like.&lt;/p&gt;
</description>
                <link>http://birdor.github.io/lessons/2011/12/jekyll-introduction</link>
                <guid>http://birdor.github.io/lessons/2011/12/jekyll-introduction</guid>
                <pubDate>2011-12-29T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
